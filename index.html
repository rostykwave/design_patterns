<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Start</title>
  </head>
  <body>
    <h1>Factory Method</h1>
    <h2>description</h2>
    <ul>
      <li>
        Визначає загальний інтерфейс для створення об’єктів у суперкласі (виклик
        фабричного методу)
      </li>
      <li>Дозволяє підкласам змінювати тип створюваних об’єктів</li>
      <li>
        Щоб змінити тип створюваного продукту достатньо перевизначити фабричний
        метод у підкласі
      </li>
      <li>У продуктів, що повертаються повинен бути спільний інтерфейс</li>
      <li>
        Здебільшого “фабрика” - це всього лише додаткова роль для цього класу.
        Базовий клас фабрики, скоріше за все, вже має якусь бізнес-логіку, яка
        потребує створення продуктів
      </li>
    </ul>
    <h2>implementation</h2>
    <ul>
      <li>
        Конкретний Продукт імплементує інтерфейс Продукт (Product.operation)
      </li>
      <li>
        Конкретний Творець розширює абстрактний клас Творець та імплементує
        factoryMethod, що повертає новий Конкретний Продукт.
      </li>
      <li>
        Клієнтський код отримує в параметри нового Конкретного Творця і
        використовує його методи (Creator.someOperation), які зазначені в
        абстрактному класі Творець.
      </li>
      <li>
        Методи Конкретного Творця (Creator.someOperation) створюють новий
        продукт (const product = this.factoryMethod) і використовують методи
        Конкретного Продукту (Product.operation).
      </li>
      <li>
        Також зауважте, що, незважаючи на назву, основним обов’язком Творця є не
        створення продуктів.
      </li>
      <li>
        Зазвичай він містить певну основну бізнес-логіку
        (Creator.someOperation), яка покладається на об’єкти Product
        (Product.operation), повернуті фабричним методом (const product =
        this.factoryMethod).
      </li>
      <li>
        Підкласи можуть опосередковано змінювати цю бізнес-логіку, переписуючи
        фабричний метод і повертаючи з нього інший тип продукту.
      </li>
      <li>
        Зазвичай, фабричний метод оголошують абстрактним, щоб змусити всі
        підкласи реалізувати його по-своєму. Однак він може також повертати
        продукт за замовчуванням (як в даному прикладі).
      </li>
    </ul>
    <h2>usecases</h2>
    <ul>
      <li>
        Коли типи і залежності об’єктів, з якими повинен працювати ваш код,
        невідомі заздалегіть
      </li>
      <li>
        Коли ви хочете надати користувачам можливість розширювати частини вашого
        фреймворку чи бібліотеки
      </li>
      <li>
        Коли ви хочете зекономити системні ресурси, повторно використовуючи вже
        створені об’єкти, замість породження нових
      </li>
    </ul>
    <script src="./dist/index.js"></script>
  </body>
</html>
