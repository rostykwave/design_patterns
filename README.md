# design_patterns

## Facade

1. description

- Надає простий інтерфейс до складної системи класів, бібліотеки або фреймворку.

2. implementation

- Підсистема може приймати запити як від фасаду, так і безпосередньо від
  клієнта. У будь-якому випадку, для Підсистеми Фасад — це ще один клієнт, і він
  не є частиною Підсистеми.
- Деякі фасади можуть працювати з кількома підсистемами одночасно.
- Клас Facade забезпечує простий інтерфейс для складної логіки однієї або
  кількох підсистем. Фасад делегує клієнтські запити відповідним об’єктам у
  підсистемі. Фасад також відповідає за керування їхнім життєвим циклом. Усе це
  захищає клієнта від небажаної складності підсистеми.
- Залежно від потреб вашої програми, ви можете надати Facade існуючі об’єкти
  підсистеми або змусити Facade створити їх самостійно.
- Методи Facade — це зручні ярлики для доступу до складної функціональності
  підсистем. Однак клієнти отримують лише частину можливостей підсистеми.
- Клієнтський код працює зі складними підсистемами через простий інтерфейс,
  наданий Facade. Коли фасад керує життєвим циклом підсистеми, клієнт може
  навіть не знати про існування підсистеми. Такий підхід дозволяє тримати
  складність під контролем.
- У коді клієнта можуть бути вже створені деякі з об’єктів підсистеми. У цьому
  випадку, можливо, варто ініціалізувати Facade цими об’єктами замість того, щоб
  дозволяти Facade створювати нові екземпляри.

3. usecases

- Приклад: Спрощення роботи зі складним фреймворком конвертації відео (залежно
  від фромату вибиратиметься кодек компресії, окремий клас працюватиме над аудіо
  тощо)
- Якщо вам потрібно надати простий або урізаний інтерфейс до складної підсистеми
- Якщо ви хочете розкласти підсистему на окремі рівні (Якщо підсистеми залежать
  одна від одної, тоді залежність можна спростити, дозволивши підсистемам
  обмінюватись інформацією через фасади, наприклад примусити класи аудіо та
  відео обробки спілкуватись один з одним через ці фасади, а не безпосередньо )
