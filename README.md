# design_patterns

## Factory Method

1. description

- Визначає загальний інтерфейс для створення об’єктів у суперкласі (виклик
  фабричного методу)
- Дозволяє підкласам змінювати тип створюваних об’єктів
- Щоб змінити тип створюваного продукту достатньо перевизначити фабричний метод
  у підкласі
- У продуктів, що повертаються повинен бути спільний інтерфейс
- Здебільшого “фабрика” - це всього лише додаткова роль для цього класу. Базовий
  клас фабрики, скоріше за все, вже має якусь бізнес-логіку, яка потребує
  створення продуктів
- Приклад: кнопка в діалоговому вікні, яка однаково працює на Windows і Mac,
  маючи спільний інтерфейс. Щоб додати підтримку Linux достатньо в клієнтський
  код додати нового творця, який буде повертати кнопку під лінукс, а саме
  реалізовувати методи інтерфейсу Кнопка (render та onClick) в стилі лінукса.

2. implementation

- Конкретний Продукт імплементує інтерфейс Продукт (Product.operation)
- Також зауважте, що, незважаючи на назву, основним обов’язком Творця є не
  створення продуктів.
- Клієнтський код отримує в параметри нового Конкретного Творця і використовує
  його методи (Creator.someOperation), які зазначені в абстрактному класі
  Творець.
- Методи Конкретного Творця (Creator.someOperation) створюють новий продукт
  (const product = _this_.factoryMethod) і використовують методи Конкретного
  Продукту (Product.operation).
- Конкретний Творець розширює абстрактний клас Творець та імплементує
  factoryMethod, що повертає новий Конкретний Продукт.
- Зазвичай Творець містить певну основну бізнес-логіку (Creator.someOperation),
  яка покладається на об’єкти Product (Product.operation), повернуті фабричним
  методом (const product = _this_.factoryMethod).
- Підкласи можуть опосередковано змінювати цю бізнес-логіку, переписуючи
  фабричний метод і повертаючи з нього інший тип продукту.
- Зазвичай, фабричний метод оголошують абстрактним, щоб змусити всі підкласи
  реалізувати його по-своєму. Однак він може також повертати продукт за
  замовчуванням (як в даному прикладі).

3. usecases

- Коли типи і залежності об’єктів, з якими повинен працювати ваш код, невідомі
  заздалегіть
- Коли ви хочете надати користувачам можливість розширювати частини вашого
  фреймворку чи бібліотеки
- Коли ви хочете зекономити системні ресурси, повторно використовуючи вже
  створені об’єкти, замість породження нових
